#!/usr/bin/env python

"""
Generate a large database ...
"""

# imports for py3 compatibility
from __future__ import print_function
from builtins import range

import os
import h5py
import time
import itertools as itt
import toytree
import numpy as np

from .parallel import Parallel
from .Simulator import IPCoalWrapper
from .utils import get_all_admix_edges, SimcatError, Progress



class Database:
    """
    An object to build a HD5 database with parameters (labels) for simulations.
    The number of labeled tests is equal to nevents * ntests * nreps,
    where nevents is based on the tree topology and number of admixture edges
    drawn on it (nedges). Typical use is to provide a fixed ultrametric tree
    and build the database for all placements of one or two admixture edges
    on the tree.

    Parameters:
    -----------
    name: str
        The name that will be used in the saved database file (<name>.hdf5)

    workdir: str
        The location where the database file will be saved, or loaded from
        if continuing an analysis from a checkpoint.

    tree: newick or toytree
        A fixed topology to use for all simulations. Edge lengths are fixed
        unless the argument 'edge_function' is used, in which case edge lengths
        are drawn from a distribution.

    Ne_min: int (default=1e4)
        Effective population size (Ne) minimum value sampled randomly 
        across ntests.

    Ne_max: int (default=1e5)
        Effective population size (Ne) maximum value sampled randomly 
        across ntests.

    existing_admix_edges: list (default=list())
        This should be a list of tuples. Each tuple should have two integers: a 
        source edge and a destination edge. 

    nedges: int (default=0)
        The number of admixture edges to add to each tree at a time. All edges
        will be drawn on the tree that can connect any branches which overlap
        for a nonzero amount of time. A set of admixture scenarios
        generated by drawing nedges on a tree is referred to as nevents, and
        all possible events will be tested.
        * Each nedge increases nvalues by nevents * ntests * nreps.

    ntests: int (default=10)
        The number of parameters to draw for each admixture_event described
        by an edge but sampling different durations, magnitudes, and mutation
        rates (theta). For example, (2, 1, None, None, None) could draw
        (2, 1, 0.1, 0.3, 0.01) and theta=0.1 in one randomly drawn test,
        and (2, 1, 0.2, 0.4, 0.02) and theta=0.2 in another.
        * Each ntest increases nvalues by nreps.

    nreps: int (default=1)
        The number of replicate simulations to run per admixture scenario,
        sampled tree, and parameter set (nevent, ntree, ntest). Replicate
        simulations make identical calls to msprime but get variable result
        matrices due to variability in the coalescent process.

    nsnps: int (default=20000)
        The number of SNPs in each simulation that are used to build the
        16x16 arrays of phylogenetic invariants for each quartet sample.

    nrows: int (default=None)
        The maximum number of rows to include for each tree simulated on. If
        this value is smaller than the number of possible admixture edges, then
        the admixture events simulated will be randomly chosen for the list of
        possible events.

    seed: int (default=None)
        Set the seed of the random number generator

    force: bool (default=False)
        Force overwrite of existing database file.
    """
    def __init__(
        self,
        name,
        workdir,
        tree,
        nrows=100,
        nsnps=20000,
        existing_admix_edges=list(),
        Ne_min=10000,
        Ne_max=100000,
        admix_prop_min=0.05,
        admix_prop_max=0.50,
        admix_edge_min=0.5,
        admix_edge_max=0.5,
        exclude_sisters=False,
        node_slide_prop=0.25,
        seed=None,
        force=False,
        quiet=False,
        ):

        # init random seed generator
        self.random = np.random.RandomState(seed)

        # database locations
        self.name = name
        self.workdir = (
            workdir if workdir else os.path.realpath("./databases"))
        if not os.path.exists(workdir):
            os.makedirs(workdir)

        # labels data file
        self.labels = os.path.realpath(
            os.path.join(workdir, "{}.labels.h5".format(self.name)))
        # counts data file
        self.counts = os.path.realpath(
            os.path.join(workdir, "{}.counts.h5".format(self.name)))
        self.checkpoint = 0
        self._quiet = quiet

        # store params
        self.tree = (
            toytree.tree(tree) if isinstance(tree, str) else tree.copy())

        # deal with imprecision issues
        self.tree = toytree.tree(self.tree.write())
        
        self.existing_admix_edges = existing_admix_edges
        self.Ne_min = Ne_min
        self.Ne_max = Ne_max
        self.inodes = self.tree.nnodes - self.tree.ntips
        self.node_slide_prop = node_slide_prop
        
        self.nrows = nrows

        self.admix_edge_min = admix_edge_min
        self.admix_edge_max = admix_edge_max
        self.admix_prop_min = admix_prop_min
        self.admix_prop_max = admix_prop_max
        self.exclude_sisters = exclude_sisters
        # vary the height!
        self.heightmax = self.tree.treenode.height * 1.5
        self.heightmin = self.tree.treenode.height * 0.5

        # database label combinations
        self.nedges = len(self.existing_admix_edges)+1
        self.nnes = 1  # n_sampled_Ne
        self.nsnps = nsnps
        self.nquarts = sum(1 for i in itt.combinations(range(tree.ntips), 4))

        # get number of places to put admix edges on THIS tree. If node slider
        # is on then we might observe other edges, in which case there will 
        # just be fewer of these edges in that 'test'. In each test the order
        # of placement of admix edges will be random so that node slide admix
        # edges that get added can be worked in without changing the total 
        # number of tests. 
        args = (self.tree, 0.5, 0.5, self.exclude_sisters)
        admixedges = get_all_admix_edges(*args)
        self.aedges = [self.existing_admix_edges + [i] for i in list(admixedges.keys())]
        self.nstored_labels = (
            self.nrows * self.nnes)

        # create or clear the database for writing
        self.init_databases(force)

        # print to user a progress report 
        if not self._quiet:
            shortpath = self.labels
            if os.path.abspath("..") in shortpath:
                shortpath = shortpath.replace(os.path.abspath(".."), "..")
            if os.path.expanduser("~") in shortpath:
                shortpath = shortpath.replace(os.path.expanduser("~"), "~")
            print("{} labels to be stored in: {}".format(
                self.nstored_labels, shortpath)
            )

        # decide on an appropriate chunksize to keep memory load reasonable
        self.chunksize = 100

        # store ipcluster information
        self.ipcluster = {
            "cluster_id": "",
            "profile": "default",
            "engines": "Local",
            "quiet": 0,
            "timeout": 60,
            "cores": 0,
            "threads": 2,
            "pids": {},
        }

        # fill the database
        self.fill_labels_database()



    def database_status(self):
        """
        Prints to screen info about the size of the database files and the
        progress/checkpoint for filling the databases.
        """
        print(self.nstored_labels)
        with h5py.File(self.labels) as io5:
            for key in io5.keys:
                print(key, io5[key].shape)

        with h5py.File(self.counts) as io5:
            print('counts', io5["counts"].shape)



    def init_databases(self, force=False):
        """
        Parses parameters in self.params to create all combinations
        of parameter values to test. Returns the number of the simulations.
        Simulation metadata is appended to datasets.

        Expect that the h5 file self._db is open in w or a mode.
        """
        # create database in 'w-' mode to prevent overwriting
        if not os.path.exists(self.labels):
            i5 = h5py.File(self.labels, mode='w')
            o5 = h5py.File(self.counts, mode='w')
        else:
            if force:
                i5 = h5py.File(self.labels, mode='w')
                o5 = h5py.File(self.counts, mode='w')
            else:
                return 
                # i5 = h5py.File(self.labels, mode='a')
                # o5 = h5py.File(self.counts, mode='a')

        # store some database attribute info
        i5.attrs["tree"] = self.tree.write()
        o5.attrs["tree"] = self.tree.write()
        i5.attrs["nsnps"] = self.nsnps
        o5.attrs["nsnps"] = self.nsnps
        i5.attrs["nquarts"] = self.nquarts
        o5.attrs["nquarts"] = self.nquarts
        i5.attrs["ntips"] = self.tree.ntips
        o5.attrs["ntips"] = self.tree.ntips
        i5.attrs["node_slide_prop"] = self.node_slide_prop
        o5.attrs["node_slide_prop"] = self.node_slide_prop

        # store data in separate dsets and with matrix shape so that in the 
        # analysis we can best take advantage of different combinations of the
        # data and its structure.
        smat = (self.nstored_labels, self.tree.ntips, self.nsnps)
        #smat = (self.nstored_labels, self.nquarts, 16, 16)

        # countsize = (self.nstored_labels, snps + svdu + svdv + svds + mvar)
        o5.create_dataset(name="counts", shape=smat, dtype=np.int64, compression="gzip")

        # array of node heights,Nes in traverse order (-tips)
        lnodes = (self.nstored_labels, self.inodes)
        allnodes = (self.nstored_labels, self.tree.nnodes)
        i5.create_dataset(name="node_heights", shape=lnodes, dtype=np.int64)
        i5.create_dataset(name="node_Nes", shape=allnodes, dtype=np.int64)
        i5.create_dataset(name="slide_seeds", shape=(lnodes[0],), dtype=np.int)
        i5.create_dataset(name="finished_sims",
                          data=np.zeros(shape=(lnodes[0],),
                                   dtype=np.int)
                          )
        i5.create_dataset(name="treeheight", shape=(lnodes[0],), dtype=np.float64)

        # array of admixture quadruplets (source, dest, time, prop)
        ashape = (self.nstored_labels, self.nedges, 4)
        i5.create_dataset(name="admixture", shape=ashape, dtype=np.float64)

        # close the files
        i5.close()
        o5.close()



    def fill_labels_database(self):
        """
        Fill the h5 database with all labels.
        """

        # arrays to write in chunks to the h5 array
        chunksize = 10000
        arr_h = np.zeros((chunksize, self.inodes), dtype=np.int)
        arr_n = np.zeros((chunksize, self.tree.nnodes), dtype=np.int)
        arr_a = np.zeros((chunksize, self.nedges, 4), dtype=np.float)
        arr_s = np.zeros((chunksize,), dtype=np.int)
        arr_d = np.zeros((chunksize,), dtype=np.float64)

        # test is a sampled nodeslide (heights, edges), migrate, migprop, Nes
        wdx = 0
        idx = 0
        for na in range(self.nrows):
            newheight = np.random.uniform(self.heightmin, self.heightmax)

            # make it taller! ...or shorter...
            ntree = self.tree.mod.node_scale_root_height(treeheight=newheight)

            # wiggle node heights
            prop = self.node_slide_prop
            slide_seed = self.random.randint(0, 1e12)
            ntree = ntree.mod.node_slider(prop=prop, seed=slide_seed)

            # this generates node-specific random Ne values for each sampled Ne
            popsizes = np.random.uniform(
                                         self.Ne_min,
                                         self.Ne_max,
                                         (1, self.tree.nnodes)
                                         )

            # store internal heights and Nes to array
            heights = ntree.get_node_values("height", 1, 1).astype(int)
            mask = heights > 0
            iheights = heights[mask]
            # ipops = popsizes[mask]

            # get n admixture edges (on this slide tree)
            aedges = list(get_all_admix_edges(ntree, self.admix_edge_min, self.admix_edge_max, self.exclude_sisters).keys())

            # keep from picking an edge that's already placed!
            for exedge in self.existing_admix_edges:
                aedges.remove(exedge)

            # pick random edges up to "rows per test"
            aes = np.random.randint(0, len(aedges), 1)
            aedges = np.array(aedges)[aes]

#            # iterate over each placement of the edges
#            for edgetup in aedges:

            arr_h[idx] = iheights
            arr_n[idx] = popsizes
            for aidx, exedge in enumerate(self.existing_admix_edges):
                arr_a[idx, aidx] = (exedge[0], exedge[1],
                                    np.random.uniform(self.admix_edge_min,
                                                      self.admix_edge_max),
                                    np.random.uniform(self.admix_prop_min,
                                                      self.admix_prop_max))
            arr_a[idx, (self.nedges-1)] = (aedges[0][0],
                                           aedges[0][1],
                                           # here is where the timing is selected
                                           np.random.uniform(self.admix_edge_min,
                                                             self.admix_edge_max),
                                           np.random.uniform(self.admix_prop_min,
                                                             self.admix_prop_max))

            arr_s[idx] = slide_seed
            arr_d[idx] = newheight
            # advance counter
            idx += 1

            # reset arrs if bigger than chunksize
            if (idx == chunksize) or (idx == self.nstored_labels):
                with h5py.File(self.labels, 'a') as i5:
                    i5["node_heights"][wdx:wdx + idx] = arr_h[:idx]
                    i5["node_Nes"][wdx:wdx + idx] = arr_n[:idx]
                    i5["admixture"][wdx:wdx + idx] = arr_a[:idx]
                    i5["slide_seeds"][wdx:wdx + idx] = arr_s[:idx]
                    i5["treeheight"][wdx:wdx + idx] = arr_d[:idx]
                    arr_h[:] = 0
                    arr_n[:] = 0
                    arr_a[:] = 0
                    arr_s[:] = 0
                    arr_d[:] = 0
                    wdx += idx
                    idx = 0
